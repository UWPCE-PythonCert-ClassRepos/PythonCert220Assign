{\rtf1\ansi\ansicpg1252\cocoartf1671\cocoasubrtf200
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 1) Initial times after adding in timeit to the program:\
1 time = 0.7642827879990364 seconds\
10 times = 7.511985463999736 seconds\
\
2) After adding parallel threading:\
1 time = 8.870010788086802e-07 seconds	\
10 times = 9.300001693191007e-07 seconds\
\
\
4) Refactoring code to return tuples per instructions on homework containing: the number of records processed (int), the record count in the database prior to running (int), the record count after running (int), and the time taken to run the module (float) resulted in the following times:\
	a. Linear threading:\
		1 time = 0.8294230100000277 seconds\
		10 times = 7.732438102000742 seconds\
	b. Parallel threading:\
		1 time = 0.6842076470056782 seconds\
		10 times = 1.4200049918144941e-06 seconds\
		- refactoring the code for the parallel threading required moving the logic for the computations on the number of records processed into the same function that adds data from the data files. This would be a good idea to do as well for the linear file as the code is much cleaner. However, I ran out of time for this. \
\
5) Conclusion: parallel threading was only slightly faster for the single execution of the file, but orders of magnitude faster when the program was run 10 times. }